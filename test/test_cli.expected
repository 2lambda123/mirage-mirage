output_main_xl
==============

# REDACTED

name = 'NAME'
kernel = 'KERNEL'
builder = 'linux'
memory = MEMORY
on_crash = 'preserve'

disk = [ 'format=raw, vdev=xvda, access=rw, target=BLOCK_PATH0', 'format=raw, vdev=xvdb, access=rw, target=BLOCK_PATH1', 'format=raw, vdev=xvdbi, access=rw, target=BLOCK_PATH60' ]

# if your system uses openvswitch then either edit /etc/xen/xl.conf and set
#     vif.default.script="vif-openvswitch"
# or add "script=vif-openvswitch," before the "bridge=" below:
vif = [ 'bridge=NETWORK1', 'bridge=NETWORK2' ]

output_main_xe
==============

#!/bin/sh
# REDACTED

set -e

# Dependency: xe
command -v xe >/dev/null 2>&1 || { echo >&2 "I require xe but it's not installed.  Aborting."; exit 1; }
# Dependency: xe-unikernel-upload
command -v xe-unikernel-upload >/dev/null 2>&1 || { echo >&2 "I require xe-unikernel-upload but it's not installed.  Aborting."; exit 1; }
# Dependency: a $HOME/.xe
if [ ! -e $HOME/.xe ]; then
  echo Please create a config file for xe in $HOME/.xe which contains:
  echo server='<IP or DNS name of the host running xapi>'
  echo username=root
  echo password=password
  exit 1
fi

echo Uploading VDI containing unikernel
VDI=$(xe-unikernel-upload --path ROOT/NAME.xen)
echo VDI=$VDI
echo Creating VM metadata
VM=$(xe vm-create name-label=NAME)
echo VM=$VM
xe vm-param-set uuid=$VM PV-bootloader=pygrub
echo Adding network interface connected to xenbr0
ETH0=$(xe network-list bridge=xenbr0 params=uuid --minimal)
VIF=$(xe vif-create vm-uuid=$VM network-uuid=$ETH0 device=0)
echo Atting block device and making it bootable
VBD=$(xe vbd-create vm-uuid=$VM vdi-uuid=$VDI device=0)
xe vbd-param-set uuid=$VBD bootable=true
xe vbd-param-set uuid=$VBD other-config:owner=true
echo Uploading data VDI FILE1
echo VDI=$VDI
SIZE=$(stat --format '%s' ROOT/FILE1)
POOL=$(xe pool-list params=uuid --minimal)
SR=$(xe pool-list uuid=$POOL params=default-SR --minimal)
VDI=$(xe vdi-create type=user name-label='FILE1' virtual-size=$SIZE sr-uuid=$SR)
xe vdi-import uuid=$VDI filename=ROOT/FILE1
VBD=$(xe vbd-create vm-uuid=$VM vdi-uuid=$VDI device=1)
xe vbd-param-set uuid=$VBD other-config:owner=true
echo Uploading data VDI FILE2
echo VDI=$VDI
SIZE=$(stat --format '%s' ROOT/FILE2)
POOL=$(xe pool-list params=uuid --minimal)
SR=$(xe pool-list uuid=$POOL params=default-SR --minimal)
VDI=$(xe vdi-create type=user name-label='FILE2' virtual-size=$SIZE sr-uuid=$SR)
xe vdi-import uuid=$VDI filename=ROOT/FILE2
VBD=$(xe vbd-create vm-uuid=$VM vdi-uuid=$VDI device=2)
xe vbd-param-set uuid=$VBD other-config:owner=true
echo Starting VM
xe vm-start uuid=$VM

output_main_libvirt_xml
=======================

# REDACTED
<domain type='xen'>
    <name>NAME</name>
    <memory unit='KiB'>262144</memory>
    <currentMemory unit='KiB'>262144</currentMemory>
    <vcpu placement='static'>1</vcpu>
    <os>
        <type arch='armv7l' machine='xenpv'>linux</type>
        <kernel>ROOT/NAME.xen</kernel>
        <cmdline> </cmdline>
    </os>
    <clock offset='utc' adjustment='reset'/>
    <on_crash>preserve</on_crash>
    <!-- 
    You must define network and block interfaces manually.
    See http://libvirt.org/drvxen.html for information about converting .xl-files to libvirt xml automatically.
    -->
    <devices>
        <!--
        The disk configuration is defined here:
        http://libvirt.org/formatstorage.html.
        An example would look like:
         <disk type='block' device='disk'>
            <driver name='phy'/>
            <source dev='/dev/loop0'/>
            <target dev='' bus='xen'/>
        </disk>
        -->
        <!-- 
        The network configuration is defined here:
        http://libvirt.org/formatnetwork.html
        An example would look like:
        <interface type='bridge'>
            <mac address='c0:ff:ee:c0:ff:ee'/>
            <source bridge='br0'/>
        </interface>
        -->
        <console type='pty'>
            <target type='xen' port='0'/>
        </console>
    </devices>
</domain>

output_virtio_libvirt_xml
=========================

# REDACTED
<domain type='kvm'>
    <name>NAME</name>
    <memory unit='KiB'>262144</memory>
    <currentMemory unit='KiB'>262144</currentMemory>
    <vcpu placement='static'>1</vcpu>
    <os>
        <type arch='x86_64' machine='pc'>hvm</type>
        <kernel>ROOT/NAME.virtio</kernel>
        <!-- Command line arguments can be given if required:
        <cmdline>-l *:debug</cmdline>
        -->
    </os>
    <clock offset='utc' adjustment='reset'/>
    <devices>
        <emulator>/usr/bin/qemu-system-x86_64</emulator>
        <!--
        Disk/block configuration reference is here:
        https://libvirt.org/formatdomain.html#elementsDisks
        This example uses a raw file on the host as a block in the guest:
        <disk type='file' device='disk'>
            <driver name='qemu' type='raw'/>
            <source file='/var/lib/libvirt/images/NAME.img'/>
            <target dev='vda' bus='virtio'/>
        </disk>
        -->
        <!-- 
        Network configuration reference is here:
        https://libvirt.org/formatdomain.html#elementsNICS
        This example adds a device in the 'default' libvirt bridge:
        <interface type='bridge'>
            <source bridge='virbr0'/>
            <model type='virtio'/>
            <alias name='0'/>
        </interface>
        -->
        <serial type='pty'>
            <target port='0'/>
        </serial>
        <console type='pty'>
            <target type='serial' port='0'/>
        </console>
        <memballoon model='none'/>
    </devices>
</domain>

output_opam
===========

# REDACTED
opam-version: "1.2"
name: "NAME"
depends: [ "pkg1" 
           "pkg2" {build}
           "pkg3" {>="3"}
           "pkg4" {<"4"}
           "pkg5" {>="5.0" & <"5.1"}
]
maintainer: "dummy"
authors: "dummy"
homepage: "dummy"
bug-reports: "dummy"
build: [ "mirage" "build" ]

output_fat
==========

#!/bin/sh

echo This uses the 'fat' command-line tool to build a simple FAT
echo filesystem image.

FAT=$(which fat)
if [ ! -x "${FAT}" ]; then
  echo I couldn\'t find the 'fat' command-line tool.
  echo Try running 'opam install fat-filesystem'
  exit 1
fi

IMG=$(pwd)/BLOCK_FILE
rm -f ${IMG}
cd ROOT/DIR
SIZE=$(du -s . | cut -f 1)
${FAT} create ${IMG} ${SIZE}KiB
${FAT} add ${IMG} REGEXP
echo Created 'BLOCK_FILE'

output_makefile
===============

# REDACTED

-include Makefile.user

OPAM = opam
DEPEXT ?= opam depext --yes --update OPAM_NAME

.PHONY: all depend depends clean build
all:: build

depend depends::
	$(OPAM) pin add -k path --no-action --yes OPAM_NAME .
	$(DEPEXT)
	$(OPAM) install --yes --deps-only OPAM_NAME
	$(OPAM) pin remove --no-action OPAM_NAME

build::
	mirage build

clean::
	mirage clean


qrexec_qubes_connect
====================

(MODNAME.connect ~domid:0 ()) >>=
  (fun qrexec ->
     Lwt.async
       (fun () ->
          (OS.Lifecycle.await_shutdown_request ()) >>=
            (fun _ -> MODNAME.disconnect qrexec));
     Lwt.return (`Ok qrexec))
gui_qubes_connect
=================

(MODNAME.connect ~domid:0 ()) >>=
  (fun gui -> Lwt.async (fun () -> MODNAME.listen gui); Lwt.return (`Ok gui))
conduit_with_connectors_connect
===============================

(Lwt.return Conduit_mirage.empty) >>=
  (CONNECTOR1 >>= (CONNECTOR2 >>= (fun t -> Lwt.return t)))
resolver_dns_conf_connect
=========================

let ns = Some (Ipaddr.V4.of_string_exn "192.168.0.1") in
let ns_port = Some 1234 in
let res = MODNAME.R.init ?ns ?ns_port ~stack:STACK () in Lwt.return res
